<script>
let parsedData = [];
let variableKeys = [];
let variableWeights = {};
let normalizedMatrix = [];

document.getElementById('csvUpload').addEventListener('change', function (e) {
  const file = e.target.files[0];
  if (!file) return;

  Papa.parse(file, {
    header: true,
    dynamicTyping: true,
    skipEmptyLines: true,
    complete: function (results) {
      const headers = results.meta.fields || [];
      parsedData = results.data;

      variableKeys = headers.filter(
        key => !["Row", "Source", "CASRN", "Name", "ToxPi Score"].includes(key)
      );

      // Extract weights like !1/16!
      variableWeights = {};
      variableKeys.forEach(key => {
        const match = key.match(/!([\d]+)\/([\d]+)!/);
        if (match) {
          const weight = parseFloat(match[1]) / parseFloat(match[2]);
          variableWeights[key] = weight;
        } else {
          variableWeights[key] = 1;
        }
      });

      // Normalize values column-by-column
      normalizedMatrix = parsedData.map(() => ({}));
      variableKeys.forEach(key => {
        const values = parsedData.map(row => parseFloat(row[key]));
        const min = Math.min(...values);
        const max = Math.max(...values);
        const range = max - min || 1;

        parsedData.forEach((row, i) => {
          const x = parseFloat(row[key]);
          normalizedMatrix[i][key] = isNaN(x) ? 0 : (x - min) / range;
        });
      });

      buildWeightInputs(variableKeys, variableWeights);
      document.getElementById('generate-section').style.display = 'block';
    }
  });
});

function buildWeightInputs(keys, weights) {
  const container = document.getElementById('weights-section');
  container.innerHTML = '<h3>Step 2: Adjust Weights</h3><div class="input-row" id="weightInputs"></div>';
  const row = document.getElementById('weightInputs');

  keys.forEach(key => {
    const labelText = key.split('!')[0];
    const defaultWeight = weights[key] || 1;
    const label = document.createElement('label');
    label.innerHTML = `${labelText} <input type="number" name="${key}" value="${defaultWeight}" min="0" step="0.001">`;
    row.appendChild(label);
  });
}

document.getElementById('generateBtn').addEventListener('click', function () {
  const weights = variableKeys.map(key => {
    const el = document.querySelector(`input[name="${key}"]`);
    return parseFloat(el?.value) || 0;
  });

  const totalWeight = weights.reduce((sum, w) => sum + w, 0) || 1;
  const normalizedWeights = weights.map(w => w / totalWeight);

  const chartGrid = document.getElementById('chartGrid');
  chartGrid.innerHTML = '';

  parsedData.forEach((row, index) => {
    const normalizedScores = variableKeys.map(key => normalizedMatrix[index][key]);
    const toxpiScore = normalizedScores.reduce(
      (sum, score, i) => sum + score * normalizedWeights[i],
      0
    );

    const block = document.createElement('div');
    block.className = 'chart-block';

    const title = document.createElement('div');
    title.className = 'chart-title';
    const name = row['Name'] || row['CASRN'] || `Row ${index + 1}`;
    title.textContent = `${name} â€” Score: ${toxpiScore.toFixed(3)}`;
    block.appendChild(title);

    const chartDiv = document.createElement('div');
    chartDiv.className = 'single-chart';
    chartDiv.id = `chart-${index}`;
    block.appendChild(chartDiv);

    chartGrid.appendChild(block);

    drawSingleChart(`chart-${index}`, variableKeys, normalizedScores, normalizedWeights);
  });
});

function drawSingleChart(containerId, labels, scores, weights) {
  let startAngle = 0;
  const traces = [];
  const colors = Array.from({ length: labels.length }, (_, i) =>
    `hsl(${i * 360 / labels.length}, 60%, 60%)`
  );

  for (let i = 0; i < labels.length; i++) {
    const angle = weights[i] * 360;
    const theta = [startAngle, startAngle, startAngle + angle, startAngle + angle];
    const r = [0, scores[i], scores[i], 0];

    traces.push({
      type: 'scatterpolar',
      mode: 'lines',
      r: r,
      theta: theta,
      fill: 'toself',
      fillcolor: colors[i],
      line: { width: 0 },
      hoverinfo: 'text',
      text: `${labels[i].split('!')[0]}<br>Score: ${scores[i].toFixed(3)}<br>Weight: ${(weights[i] * 100).toFixed(1)}%`,
      showlegend: false
    });

    startAngle += angle;
  }

  Plotly.newPlot(containerId, traces, {
    polar: {
      radialaxis: { visible: false, range: [0, 1] },
      angularaxis: { direction: 'counterclockwise', rotation: 90 }
    },
    margin: { t: 10, b: 10, l: 10, r: 10 },
    width: 300,
    height: 300
  }, { displayModeBar: false });
}
</script>
function downloadCSV() {
  const headers = ["Name", "ToxPi Score", ...variableKeys.map(k => k.split('!')[0]), ...variableKeys.map(k => k.split('!')[0] + " Weight")];
  const weightInputs = variableKeys.map(key => parseFloat(document.querySelector(`input[name="${key}"]`)?.value || 0));
  const total = weightInputs.reduce((sum, w) => sum + w, 0) || 1;
  const normWeights = weightInputs.map(w => w / total);

  const rows = parsedData.map((row, i) => {
    const name = row["Name"] || row["CASRN"] || `Row ${i + 1}`;
    const values = variableKeys.map(k => normalizedMatrix[i][k].toFixed(4));
    const weights = normWeights.map(w => w.toFixed(4));
    const score = values.reduce((sum, v, idx) => sum + parseFloat(v) * normWeights[idx], 0).toFixed(4);
    return [name, score, ...values, ...weights];
  });

  const csv = [headers.join(",")].concat(rows.map(r => r.join(","))).join("\n");
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "ToxPi_scores_export.csv";
  link.style.display = "none";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
