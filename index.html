<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ToxPi Radial Chart Generator</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 40px; }
    h2, h3 { text-align: center; }
    section { margin-bottom: 30px; }
    .input-row {
      display: flex; flex-wrap: wrap; gap: 10px;
      justify-content: center; margin: 10px 0;
    }
    label { flex: 1 1 200px; }
    input[type="number"] { width: 60px; }
    .chart-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
      gap: 40px;
      justify-conent: center;
    }
    .chart-block {
      border: 1px solid #ddd;
      border-radius: 6px;
      background: #f9f9f9;
      padding: 12px;
    }
    .chart-title {
      text-align: center;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .chart-wrapper {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      gap: 12px;
    }
    .chart-scale {
      width: 400px;
      height: 400px;
      overflow: hidden;
      position: relative;
    
      display: flex;                 /* Enable Flexbox */
      align-items: center;          /* Vertically center content */
      justify-content: center;      /* Horizontally center content */
    }
    .single-chart {
      width: 800px;
      height: 800px;
      background: white;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      transform: scale(0.5);
      transform-origin: center;
    }
    .chart-legend div {
      display: flex;
      align-items: center;
      font-size: 12px;
      margin-bottom: 4px;
    }
    .chart-legend span {
      width: 12px;
      height: 12px;
      display: inline-block;
      margin-right: 6px;
      border-radius: 2px;
    }
  </style>
</head>
<body>
  <h2>ToxPi-Style Radial Chart Generator</h2>

  <section style="text-align:center">
    <p><strong>Step 1:</strong> Upload your .csv file</p>
    <input type="file" id="csvUpload" accept=".csv" />
  </section>

  <section id="weights-section"></section>

  <section id="generate-section" style="text-align:center; display:none">
    <button id="generateBtn">Generate All Charts</button>
  </section>

  <section style="text-align:center; margin-top: 20px">
    <button onclick="downloadCSV()">Export Scores as CSV</button>
    <button onclick="exportSelectedCharts()">Export Selected as PNG</button>
    <button onclick="exportCombinedPNG()">Export Selected Charts as Composite PNG</button>
  </section>

  <section id="chartGrid" class="chart-grid"></section>

  <script>
    let parsedData = [], variableKeys = [], variableWeights = {}, normalizedMatrix = [];

    document.getElementById('csvUpload').addEventListener('change', function (e) {
      const file = e.target.files[0];
      if (!file) return;

      Papa.parse(file, {
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true,
        complete: function (results) {
          const headers = results.meta.fields || [];
          parsedData = results.data;
          variableKeys = headers.filter(
            key => !["Row", "Source", "CASRN", "Name", "ToxPi Score"].includes(key)
          );
          variableWeights = {};
          variableKeys.forEach(key => {
            const match = key.match(/!([\d]+)\/([\d]+)!/);
            variableWeights[key] = match ? parseFloat(match[1]) / parseFloat(match[2]) : 1;
          });

          normalizedMatrix = parsedData.map(() => ({}));
          variableKeys.forEach(key => {
            const values = parsedData.map(row => parseFloat(row[key]));
            const min = Math.min(...values), max = Math.max(...values);
            const range = max - min || 1;
            parsedData.forEach((row, i) => {
              const x = parseFloat(row[key]);
              normalizedMatrix[i][key] = isNaN(x) ? 0 : (x - min) / range;
            });
          });

          buildWeightInputs();
          document.getElementById('generate-section').style.display = 'block';
        }
      });
    });

    function buildWeightInputs() {
      const container = document.getElementById('weights-section');
      container.innerHTML = '<h3>Step 2: Adjust Weights</h3><div class="input-row" id="weightInputs"></div>';
      const row = document.getElementById('weightInputs');
      variableKeys.forEach(key => {
        const labelText = key.split('!')[0];
        const defaultWeight = variableWeights[key] || 1;
        const label = document.createElement('label');
        label.innerHTML = `${labelText} <input type="number" name="${key}" value="${defaultWeight}" min="0" step="0.001">`;
        row.appendChild(label);
      });
    }

    document.getElementById('generateBtn').addEventListener('click', function () {
      const weights = variableKeys.map(key => {
        const el = document.querySelector(`input[name="${key}"]`);
        return parseFloat(el?.value) || 0;
      });
      const total = weights.reduce((sum, w) => sum + w, 0) || 1;
      const normWeights = weights.map(w => w / total);
      const grid = document.getElementById('chartGrid');
      grid.innerHTML = '';

      parsedData.forEach((row, i) => {
        const scores = variableKeys.map(k => normalizedMatrix[i][k]);
        const toxpi = scores.reduce((sum, s, j) => sum + s * normWeights[j], 0);

        const block = document.createElement('div');
        block.className = 'chart-block';

        const title = document.createElement('div');
        title.className = 'chart-title';
        title.textContent = `${row["Name"] || row["CASRN"] || `Row ${i + 1}`} — Score: ${toxpi.toFixed(3)}`;
        block.appendChild(title);

        const wrapper = document.createElement('div');
        wrapper.className = 'chart-wrapper';
        wrapper.id = `wrapper-${i}`;

       const scaleWrapper = document.createElement('div');
        scaleWrapper.className = 'chart-scale';
        
        const chartDiv = document.createElement('div');
        chartDiv.className = 'single-chart';
        chartDiv.id = `chart-${i}`;
        
        scaleWrapper.appendChild(chartDiv);
        wrapper.appendChild(scaleWrapper);

        const legend = document.createElement('div');
        legend.className = 'chart-legend';
        variableKeys.forEach((k, j) => {
          const row = document.createElement('div');
          const colorBox = document.createElement('span');
          colorBox.style.backgroundColor = `hsl(${j * 360 / variableKeys.length}, 60%, 60%)`;
          row.appendChild(colorBox);
          row.append(k.split('!')[0]);
          legend.appendChild(row);
        });

        block.appendChild(wrapper);

        const checkbox = document.createElement('div');
        checkbox.style.textAlign = 'center';
        checkbox.innerHTML = `<input type="checkbox" class="download-checkbox" data-id="chart-${i}"> Select for PNG Export`;
        block.appendChild(checkbox);

        grid.appendChild(block);
        drawSingleChart(chartDiv.id, variableKeys, scores, normWeights);
      });
        createGlobalLegend();
      });

  function drawSingleChart(id, labels, scores, weights) {
  let traces = [], startAngle = 0;
  const colors = Array.from({ length: labels.length }, (_, i) =>
    `hsl(${i * 360 / labels.length}, 60%, 60%)`
  );

  for (let i = 0; i < labels.length; i++) {
    const angle = weights[i] * 360;
    const theta = [startAngle, startAngle, startAngle + angle, startAngle + angle];
    const r = [0, scores[i], scores[i], 0];
    traces.push({
      type: 'scatterpolar',
      mode: 'lines',
      r, theta,
      fill: 'toself',
      fillcolor: colors[i],
      line: { width: 0 },
      hoverinfo: 'text',
      text: `${labels[i].split('!')[0]}<br>Score: ${scores[i].toFixed(2)}<br>Weight: ${(weights[i] * 100).toFixed(1)}%`,
      showlegend: false
    });
    startAngle += angle;
  }

Plotly.newPlot(id, traces, {
  polar: {
    radialaxis: {
      visible: true,
      showticklabels: false,
      ticks: '',
      showline: false,
      gridcolor: '#ccc',
      gridwidth: 1,
      range: [0, 1]
    },
    angularaxis: {
      direction: 'counterclockwise',
      rotation: 90,
      showticklabels: false,
      ticks: '',
      showline: false
    },
    domain: {
      x: [0.1, 0.9], // shift diagram right
      y: [0.1, 0.9]  // shift diagram down
    }
  },
  margin: {
    t: 10, b: 10, l: 10, r: 10,
    pad: 4
  },
  width: 800,
  height: 800
}, {
  displayModeBar: false
}).then(() => {
  // ✅ Force a reflow after rendering
  requestAnimationFrame(() => {
    Plotly.Plots.resize(document.getElementById(id));
  });
});
}
      
function createGlobalLegend() {
  const existing = document.getElementById('global-legend');
  if (existing) existing.remove();

  const legend = document.createElement('div');
  legend.id = 'global-legend';
  legend.className = 'chart-legend';
  legend.style.maxWidth = '1000px';
  legend.style.margin = '40px auto';
  legend.style.display = 'grid';
  legend.style.gridTemplateColumns = 'repeat(auto-fit, minmax(200px, 1fr))';
  legend.style.rowGap = '10px';
  legend.style.columnGap = '20px';

  variableKeys.forEach((k, j) => {
    const row = document.createElement('div');
    const colorBox = document.createElement('span');
    colorBox.style.backgroundColor = `hsl(${j * 360 / variableKeys.length}, 60%, 60%)`;
    Object.assign(colorBox.style, {
      width: '16px',
      height: '16px',
      display: 'inline-block',
      marginRight: '6px',
      borderRadius: '3px'
    });

    row.appendChild(colorBox);
    row.append(k.split('!')[0]);
    legend.appendChild(row);
  });

  document.body.appendChild(legend);
}

function downloadCSV() {
  if (!parsedData.length) {
    alert("No data to export yet. Please upload a CSV and generate charts first.");
    return;
  }

  const weights = variableKeys.map(key => {
    const el = document.querySelector(`input[name="${key}"]`);
    return parseFloat(el?.value) || 0;
  });
  const total = weights.reduce((sum, w) => sum + w, 0) || 1;
  const normWeights = weights.map(w => w / total);

  const headers = ["Name", "ToxPi Score", ...variableKeys];
  const rows = [headers];

  parsedData.forEach((row, i) => {
    const scores = variableKeys.map(k => normalizedMatrix[i][k]);
    const toxpi = scores.reduce((sum, s, j) => sum + s * normWeights[j], 0);
    const name = row["Name"] || row["CASRN"] || `Row ${i + 1}`;
    rows.push([name, toxpi.toFixed(3), ...scores.map(s => s.toFixed(3))]);
  });

  const csvContent = rows.map(r => r.join(",")).join("\n");
  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "toxpi_scores_expanded.csv";
  link.click();
}
 
function exportSelectedCharts() {
  const checkboxes = Array.from(document.querySelectorAll('.download-checkbox:checked'));

  if (checkboxes.length === 0) {
    alert('No charts selected for export.');
    return;
  }

  // 🧠 Extract info and parse score
  const tractScores = checkboxes.map(cb => {
    const chartId = cb.dataset.id;
    const chartBlock = document.getElementById(chartId)?.closest('.chart-block');
    const title = chartBlock?.querySelector('.chart-title')?.textContent || '';
    const match = title.match(/Score[:\s]+([\d.]+)/);
    const score = match ? parseFloat(match[1]) : 0;
    return { chartId, chartBlock, title, score };
  });

  // 🔢 Sort charts by score
  tractScores.sort((a, b) => b.score - a.score);

  // 🏅 Assign ranks
  tractScores.forEach((item, index) => {
    item.rankText = `Rank: ${index + 1} of ${tractScores.length}`;
  });

  // 🖼️ Export each chart
  tractScores.forEach(({ chartId, chartBlock, title, rankText }, index) => {
    const chartDiv = chartBlock?.querySelector('.single-chart');
    if (!chartDiv) {
      console.warn(`⚠️ Skipping chart: ${chartId} (missing plotly-graph-div)`);
      return;
    }

    Plotly.toImage(chartDiv, {
      format: 'png',
      width: 800,
      height: 800
    }).then(dataUrl => {
      const safeTitle = title.replace(/[\s\/\\:<>?*|"]/g, '_');
      const filename = `${chartId}_Rank${index + 1}_${safeTitle}.png`;

      const link = document.createElement('a');
      link.href = dataUrl;
      link.download = filename;
      link.click();
    }).catch(err => {
      console.error(`❌ Failed to export ${chartId}`, err);
    });
  });
}
     async function exportCombinedPNG() {
    const checkboxes = Array.from(document.querySelectorAll('.download-checkbox:checked'));
  
    if (checkboxes.length === 0) {
      alert('No charts selected for export.');
      return;
    }
  
    // 🧠 Extract chart info and compute score
    const tractScores = checkboxes.map(cb => {
      const chartId = cb.dataset.id;
      const chartBlock = document.getElementById(chartId)?.closest('.chart-block');
      const title = chartBlock?.querySelector('.chart-title')?.textContent || '';
      const match = title.match(/Score[:\s]+([\d.]+)/);
      const score = match ? parseFloat(match[1]) : 0;
      return { chartId, chartBlock, title, score };
    });
  
    // 🔢 Sort and rank
    tractScores.sort((a, b) => b.score - a.score);
    tractScores.forEach((item, index) => {
      item.rank = index + 1;
    });
  
    // 📐 Set layout parameters
    const chartsPerRow = 5;
    const chartSize = 800;
    const rows = Math.ceil(tractScores.length / chartsPerRow);
    const canvasWidth = chartsPerRow * chartSize;
    const canvasHeight = rows * chartSize;
  
    const canvas = document.createElement('canvas');
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    const ctx = canvas.getContext('2d');
  
    // 🖼️ Composite rendering
    for (let i = 0; i < tractScores.length; i++) {
      const { chartBlock, chartId, rank, title } = tractScores[i];
      const chartDiv = chartBlock?.querySelector('.single-chart');
  
      if (!chartDiv) {
        console.warn(`⚠️ Skipping ${chartId}: missing chart container`);
        continue;
      }
  
      try {
        const imgData = await Plotly.toImage(chartDiv, {
          format: 'png',
          width: chartSize,
          height: chartSize
        });
  
        const img = new Image();
        img.src = imgData;
  
        await new Promise(resolve => img.onload = resolve);
  
        const x = (i % chartsPerRow) * chartSize;
        const y = Math.floor(i / chartsPerRow) * chartSize;
  
        ctx.drawImage(img, x, y, chartSize, chartSize);
      } catch (err) {
        console.error(`❌ Error rendering ${chartId}`, err);
      }
    }
  
    // 💾 Save composite PNG
    const link = document.createElement('a');
    link.href = canvas.toDataURL('image/png', 1.0);
    link.download = `ToxPi_Export_${new Date().toISOString().slice(0, 10)}.png`;
    link.click();
  }
</script>
</body>
</html>
